---
phase: 02-core-playback-scrubbing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useScrubberControls.ts
  - src/lib/constants.ts
  - src/components/ControlBar.tsx
  - src/components/ScrubberShell.tsx
  - src/lib/settings.ts
autonomous: true

must_haves:
  truths:
    - "User can hold rewind/forward buttons and video scrubs smoothly without visible stutter"
    - "Scrubbing speed is consistent in both forward and reverse directions"
    - "Scrubbing speed is configurable (default 2x multiplier)"
    - "Scrub speed multiplier setting persists across sessions"
  artifacts:
    - path: "src/hooks/useScrubberControls.ts"
      provides: "RAF-based smooth hold-to-scrub implementation"
      exports: ["useScrubberControls"]
      min_lines: 80
    - path: "src/lib/constants.ts"
      provides: "SCRUB_SPEED_MULTIPLIER constant"
      contains: "SCRUB_SPEED_MULTIPLIER"
    - path: "src/components/ControlBar.tsx"
      provides: "Scrub speed multiplier input in UI"
      contains: "scrubSpeedMultiplier"
  key_links:
    - from: "src/hooks/useScrubberControls.ts"
      to: "requestAnimationFrame"
      via: "RAF loop for smooth scrubbing"
      pattern: "requestAnimationFrame"
    - from: "src/hooks/useScrubberControls.ts"
      to: "controller.seekTo"
      via: "time-based seeking (startTime + elapsed * multiplier)"
      pattern: "seekTo.*elapsed"
---

<objective>
Replace setInterval-based hold-to-scrub with RAF-based smooth scrubbing using time-based seeking.

Purpose: Fix stuttering caused by YouTube's variable seek latency. Time-based RAF scrubbing (seek to calculated position based on elapsed time) is smooth and consistent, while setInterval + small steps stutters at 100-500ms per seek.

Output: Smooth bidirectional hold-to-scrub with configurable speed multiplier (default 2x = 2 seconds of video per 1 second of holding).
</objective>

<execution_context>
@C:\Users\Daniel\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Daniel\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@h:/film/.planning/PROJECT.md
@h:/film/.planning/ROADMAP.md
@h:/film/.planning/STATE.md
@h:/film/.planning/phases/01-touch-native-foundation/01-02-SUMMARY.md
@h:/film/src/hooks/useScrubberControls.ts
@h:/film/src/lib/constants.ts
@h:/film/src/components/ControlBar.tsx
@h:/film/src/components/ScrubberShell.tsx
</context>

<tasks>

<task type="auto">
  <name>Add scrub speed multiplier constant and remove hold tick rate</name>
  <files>src/lib/constants.ts</files>
  <action>
1. Remove `HOLD_TICK_RATE_MS` constant (replaced by RAF-based scrubbing)
2. Add `SCRUB_SPEED_MULTIPLIER` constant:
```typescript
export const SCRUB_SPEED_MULTIPLIER = {
  default: 2,
  min: 0.5,
  max: 10,
} as const;
```

This defines the scrubbing speed: default 2x means holding for 1 real second scrubs 2 seconds of video. Higher multipliers = faster scrubbing (useful for long videos), lower = more precise control.
  </action>
  <verify>Run `npm run build` to check TypeScript compilation</verify>
  <done>HOLD_TICK_RATE_MS removed, SCRUB_SPEED_MULTIPLIER added, build succeeds</done>
</task>

<task type="auto">
  <name>Replace setInterval scrubbing with RAF time-based scrubbing in useScrubberControls</name>
  <files>src/hooks/useScrubberControls.ts</files>
  <action>
**Key insight:** YouTube's seekTo has variable latency (100-500ms). setInterval + small steps stutters because each interval tick waits for seek to complete. RAF with time-based seeking is smooth because we calculate target position based on elapsed wall-clock time, not completed seeks.

**Implementation:**

1. Remove imports: `STEP_PRESETS`, `StepPresetKey`
2. Remove params: `stepPreset: StepPresetKey`, `holdTickRateMs: number`
3. Add param: `scrubSpeedMultiplier: number`
4. Remove: `stepSize` derived from STEP_PRESETS
5. Remove: `holdIntervalRef` (replaced with `rafIdRef`)
6. Add refs:
```typescript
const rafIdRef = useRef<number | null>(null);
const holdStartTimeRef = useRef<number | null>(null);
const videoStartTimeRef = useRef<number | null>(null);
```

7. Update `clearHold` to cancel RAF instead of interval:
```typescript
const clearHold = useCallback(() => {
  if (rafIdRef.current) {
    cancelAnimationFrame(rafIdRef.current);
    rafIdRef.current = null;
  }
  holdStartTimeRef.current = null;
  videoStartTimeRef.current = null;
}, []);
```

8. Remove `step` function entirely (frame stepping removed in plan 02-01)

9. Keep `jump` function unchanged (already works with seconds)

10. Replace `startHoldRewind` with RAF-based implementation:
```typescript
const startHoldRewind = useCallback(() => {
  if (!controller?.ready) return;
  clearHold();
  wasPlayingRef.current = controller.isPlaying;
  controller.pause();
  setHoldDirection("rewind");

  const videoStart = controller.getCurrentTime();
  videoStartTimeRef.current = videoStart;
  holdStartTimeRef.current = performance.now();

  const scrub = () => {
    if (!controller?.ready || holdStartTimeRef.current === null || videoStartTimeRef.current === null) return;

    const elapsed = (performance.now() - holdStartTimeRef.current) / 1000; // seconds
    const targetTime = Math.max(0, videoStartTimeRef.current - (elapsed * scrubSpeedMultiplier));

    controller.seekTo(targetTime);
    rafIdRef.current = requestAnimationFrame(scrub);
  };

  rafIdRef.current = requestAnimationFrame(scrub);
}, [controller, scrubSpeedMultiplier, clearHold]);
```

11. Replace `startHoldForward` similarly:
```typescript
const startHoldForward = useCallback(() => {
  if (!controller?.ready) return;
  clearHold();
  wasPlayingRef.current = controller.isPlaying;
  controller.pause();
  setHoldDirection("forward");

  const videoStart = controller.getCurrentTime();
  const duration = controller.duration || Infinity;
  videoStartTimeRef.current = videoStart;
  holdStartTimeRef.current = performance.now();

  const scrub = () => {
    if (!controller?.ready || holdStartTimeRef.current === null || videoStartTimeRef.current === null) return;

    const elapsed = (performance.now() - holdStartTimeRef.current) / 1000; // seconds
    const targetTime = Math.min(duration, videoStartTimeRef.current + (elapsed * scrubSpeedMultiplier));

    controller.seekTo(targetTime);
    rafIdRef.current = requestAnimationFrame(scrub);
  };

  rafIdRef.current = requestAnimationFrame(scrub);
}, [controller, scrubSpeedMultiplier, clearHold]);
```

12. Update return statement: remove `stepBack`, `stepForward`, `stepSize` (no longer needed)

**Why this works:** We capture the video start time when hold begins, then each RAF tick calculates target position = startTime ± (elapsedRealSeconds × multiplier). YouTube's seek completes when it completes, but we're always seeking to the "correct" position for the current wall-clock time. This eliminates stutter.
  </action>
  <verify>Run `npm run build` to check TypeScript compilation and ensure no type errors from removed step functions</verify>
  <done>RAF-based scrubbing implemented, setInterval removed, step functions removed, build succeeds</done>
</task>

<task type="auto">
  <name>Update settings storage and UI for scrub speed multiplier</name>
  <files>src/lib/settings.ts, src/components/ScrubberShell.tsx, src/components/ControlBar.tsx</files>
  <action>
**In src/lib/settings.ts:**
1. Remove `holdTickRateMs` field from Settings type
2. Add `scrubSpeedMultiplier: number` field
3. Update `DEFAULT_SETTINGS` to include `scrubSpeedMultiplier: SCRUB_SPEED_MULTIPLIER.default`

**In src/components/ScrubberShell.tsx:**
1. Remove `holdTickRateMs` state
2. Add `scrubSpeedMultiplier` state initialized to `SCRUB_SPEED_MULTIPLIER.default`
3. Update loadSettings/saveSettings effects to use `scrubSpeedMultiplier` instead of `holdTickRateMs`
4. Update URL state handling (buildSearchParams/parseUrlState) to use `scrubSpeed` param instead of `holdTick`
5. Update `useScrubberControls` call to pass `scrubSpeedMultiplier` instead of `stepPreset` and `holdTickRateMs`
6. Update `ControlBar` props to pass `scrubSpeedMultiplier` and `onScrubSpeedMultiplierChange`

**In src/components/ControlBar.tsx:**
1. Import `SCRUB_SPEED_MULTIPLIER` from constants
2. Remove props: `holdTickRateMs`, `onHoldTickRateMsChange`
3. Add props: `scrubSpeedMultiplier?: number`, `onScrubSpeedMultiplierChange?: (mult: number) => void`
4. Add scrub speed input after hold buttons (replaces old hold tick rate input):
```tsx
{onScrubSpeedMultiplierChange && (
  <label className="flex items-center gap-1 text-sm">
    <span className="text-zinc-600 dark:text-zinc-400">Scrub speed:</span>
    <input
      type="number"
      min={SCRUB_SPEED_MULTIPLIER.min}
      max={SCRUB_SPEED_MULTIPLIER.max}
      step={0.5}
      value={scrubSpeedMultiplier}
      onChange={(e) => onScrubSpeedMultiplierChange(Number(e.target.value))}
      className="w-14 rounded border border-zinc-300 bg-white px-1 py-0.5 text-sm dark:border-zinc-600 dark:bg-zinc-800 dark:text-zinc-100"
      aria-label="Scrub speed multiplier"
    />
    <span className="text-xs text-zinc-500 dark:text-zinc-400">×</span>
  </label>
)}
```

This allows users to adjust scrub speed from 0.5× (slow precise control) to 10× (fast navigation of long videos).
  </action>
  <verify>Run `npm run dev`, load video, test: (1) hold buttons scrub smoothly, (2) change scrub speed input and verify scrubbing speed changes, (3) refresh page and verify scrub speed persists</verify>
  <done>Settings updated, UI shows scrub speed input, scrubbing is smooth and configurable, settings persist</done>
</task>

</tasks>

<verification>
1. Run `npm run build` — no TypeScript errors
2. Run `npm run dev` — app starts successfully
3. Load YouTube video
4. Hold rewind button — video scrubs backward smoothly (no stutter)
5. Hold forward button — video scrubs forward smoothly at same visual speed as rewind
6. Change scrub speed input from 2 to 5 — hold buttons now scrub 5× faster
7. Change scrub speed to 0.5 — hold buttons scrub slower (more precise)
8. Refresh page — scrub speed setting persists
9. Compare to old behavior: no visible stutter or lag during scrubbing
</verification>

<success_criteria>
- Hold-to-scrub uses requestAnimationFrame instead of setInterval
- Scrubbing is smooth in both directions (no visible stutter or frame skipping)
- Scrub speed is consistent forward and backward
- Scrub speed multiplier is configurable via input (default 2×, range 0.5-10×)
- Scrub speed setting persists in localStorage
- No TypeScript errors, app builds and runs
</success_criteria>

<output>
After completion, create `h:/film/.planning/phases/02-core-playback-scrubbing/02-02-SUMMARY.md` following the summary template.
</output>
